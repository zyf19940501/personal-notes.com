---
title: 数据库与 R 包 dbplyr 交互
author: 宇飞的世界
date: '2021-06-11'
slug: dbplyr-study
categories:
  - R package
tags:
  - dbplyr
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<div id="前言" class="section level2">
<h2>前言</h2>
<p>dbplyr 将 dplyr 包的函数转化为 SQL 语句去服务器(数据库)获取数据,在数据量较大、计算较多时,将远程连接数据库中
的表当作内存中的数据使用.当你使用的本机内存不够大时,可以充分利用服务器的性能(内存),这样做的好处不言而喻.</p>
<p>至于为什么使用 dbplyr 而不是直接编写 SQL,本人觉得优势如下所示：</p>
<ul>
<li><p>dbplyr 写起来简洁高效,基本跟用 dplyr 没有差别</p></li>
<li><p>能利用数据库所在服务器的算力,配合上并行计算,在处理大量数据时,大大加快速度.</p></li>
<li><p>不同数据库的语法存在差异,当源数据存在不同数据库时,用 R 包 dbplyr 和 dplyr 的统一语法,清洗数据加快效率</p></li>
<li><p>通过 dplyr 动词方便实现复杂的逻辑,当逻辑越复杂时 dbplyr 的优势越明显,不用一层层嵌套语句.</p></li>
</ul>
<p>当然也有一些劣势,比如在SQL Server 中 SQL 可以跨库查询,但是 dbplyr 无法直接跨库查询.</p>
<blockquote>
<p>dbplyr 在 oracle 可以跨不同 schema 查询</p>
</blockquote>
<p><a href="https://dbplyr.tidyverse.org/articles/dbplyr.html">dbplyr项目地址</a></p>
</div>
<div id="dbplyr-介绍" class="section level2">
<h2>dbplyr 介绍</h2>
<p>我们想要在数据库中使用<a href="https://bookdown.org/zhongyufei/Data-Handling-in-R/Data-Manipulation-dplyr.html">dplyr</a> ,需要先安装 dbplyr：</p>
<pre class="r"><code>install.packages(&quot;dbplyr&quot;)</code></pre>
<p>还需要有 R 包 DBI, DBI提供通用的接口,允许 dplyr 使用相同的代码函数处理不同的数据框,DBI 是 dbplyr 的依赖包,会跟随 dbplyr 安装.在我们使用dbplyr之前,需要确保已有数据库后端,比如常用的 <code>RMariaDB</code>,<code>RPostgres</code>,<code>RSQLite</code>,<code>odbc</code>,<code>ROracle</code>.如我常用 dbplyr 操作 MS SQL Server,就是使用 <code>odbc</code> 后端.</p>
<p>在本文介绍中,我们将主要使用<code>RSQLite</code>后端,因为这个数据库完全嵌入在R包,不依赖本地数据库环境,也不需要设置数据库服务器.所以说SQLite非常适合演示 『dbplyr 与 数据库交互』.本文将通过演示与 SQLite 交互,学习使用 dbplyr 包;最后在实际案例中演示,dbplyr 通过后端<code>odbc</code> 与 MS SQL Server 交互.</p>
<p>另外关于 R 语言 与数据库的交互,请参考我的<a href="https://bookdown.org/zhongyufei/Data-Handling-in-R/database.html">数据处理笔记</a>数据库章节.</p>
</div>
<div id="连接数据库" class="section level2">
<h2>连接数据库</h2>
<p>在 dbplyr 中使用数据库,首先需要通过<code>DBI::dbConnect()</code>连接数据库,关于怎么连接数据库详见数据处理笔记.</p>
<p>使用RSQLite 创建内存数据库:</p>
<pre class="r"><code>library(dplyr)
library(DBI)
library(RSQLite)
library(dbplyr)
con &lt;- dbConnect(SQLite(), dbname = &quot;:memory:&quot;)</code></pre>
<p>一般情况下,数据库存在另外一台服务器上,我们需要这样连接,以 MS SQL 举例:</p>
<pre class="r"><code>con_study &lt;- dbConnect(odbc::odbc(),
  .connection_string =
    &quot;driver={ODBC Driver 17 for SQL Server};
                    server=192.168.2.236;
                    database=study;
                    uid=zhongyf;
                    pwd=Zyf123456&quot;, timeout = 10
)</code></pre>
<p>我们的临时内存数据库中暂时没有数据,需要我们将数据暂时保存到数据库中.通过<code>dplyr::copy_to()</code>即可:</p>
<pre class="r"><code>copy_to(con, nycflights13::flights, name = &quot;flights&quot;)</code></pre>
<p>现在在我们的临时数据库中已经有数据集了,我们可以通过<code>dbplyr::tbl()</code>来查看引用表:</p>
<pre class="r"><code>flights_db &lt;- tbl(con, &quot;flights&quot;)</code></pre>
<p>当我们查看获取的数据时,我们发现和本地的数据源导入R后基本一样:</p>
<pre class="r"><code>flights_db</code></pre>
<p>主要区别:我们看到数据源是来源数据库的远程数据源.</p>
</div>
<div id="查询数据库" class="section level2">
<h2>查询数据库</h2>
<p>我们在数据库中交互式,通常使用 SQL 查询,dbplyr 的目的是自动生成 SQL,但是 SQL 是一种非常大的语言,dbplyr 并不能完全代替,但是作为数据分析常用的 SQL,dbplyr 大部分都能帮助我们自动生成,我们可以继续使用我们熟悉的 dplyr 动词.</p>
<ul>
<li>select</li>
</ul>
<pre class="r"><code>flights_db %&gt;% select(year:day, dep_delay, arr_delay)

flights_db %&gt;% filter(dep_delay &gt; 240)

flights_db %&gt;%
  group_by(dest) %&gt;%
  summarise(delay = mean(dep_time))</code></pre>
<p>普通的数据框和远程数据库查询之间的最重要区别在于,我们写的 R 代码被翻译成 SQL 并在远程服务器上的数据库中执行,而不是在本地的电脑上的 R 中执行.</p>
<p>在处理数据库时,dbplyr的懒惰特性将:</p>
<ul>
<li>除非我们明确要求,否则数据将永远不在 R 中,也就是永远存在在远程服务器中.</li>
<li>我们可以写很多 R 代码,最后将全部想做的事情,到最后再发给远程服务器的数据库中执行.</li>
</ul>
<p>如下所示:</p>
<pre class="r"><code>temp &lt;- flights_db %&gt;%
  group_by(tailnum) %&gt;%
  summarise(delay = mean(arr_delay), n = n()) %&gt;%
  arrange(desc(delay)) %&gt;%
  filter(n &gt; 100)</code></pre>
<p>通过运行上述代码,我们发现基本没有运行时间,也就是说上述代码并没有真正和数据库交互运行.直到我们请求数据(打印),dplyr 才会生成 SQL ,并从数据库请求结果.即使是打印数据,也没有将全部的数据参与运行,尽可能少的拉取几行返回.</p>
<p>通过<code>show_query()</code>我们可以看到 dplyr 生成的 SQL:</p>
<pre class="r"><code>temp %&gt;% show_query()</code></pre>
<p>当我们编写调试完 R 代码后,我们通过<code>collect()</code>将数据从远程数据库中拉取到本地R中.</p>
<pre class="r"><code>temp_tbl &lt;- temp %&gt;% collect()
temp_tbl</code></pre>
</div>
<div id="函数解释" class="section level2">
<h2>函数解释</h2>
<div id="内存数据库" class="section level3">
<h3>内存数据库</h3>
<p>由于SQLite 是完全内嵌在 R 中,所以特别合适作为演示数据库,那怎么创建一个临时的数据库呢?如下所示:</p>
<pre class="r"><code>library(RSQLite)
con &lt;- dbConnect(SQLite(), dbname = &quot;:memory:&quot;)</code></pre>
<p>创建本地数据库 my-db.sqlite,通过这种方法创建的数据库会在当前目录下生成 my-db.sqlite 的文件,该文件即数据库文件.</p>
<pre class="r"><code># 创建 my-db 并连接
mydb &lt;- dbConnect(RSQLite::SQLite(), &quot;my-db.sqlite&quot;)
# 断开连接
dbDisconnect(mydb)
# 删除数据库文件
unlink(&quot;my-db.sqlite&quot;)</code></pre>
<p>或者是通过<code>dbname = ""</code>建立,该方式会临时在磁盘建立数据库,在关闭连接时会自动删除.</p>
<pre class="r"><code>con &lt;- dbConnect(SQLite(), dbname = &quot;&quot;)</code></pre>
</div>
<div id="tbl" class="section level3">
<h3>tbl</h3>
<p><code>tbl()</code>是 dplyr 里面的动词函数,是一个基于<code>src</code>调度的通用方法,从数据库中返回一个<code>tbl_dbi</code>对象.</p>
<pre class="r"><code>tbl(src, from, ...)</code></pre>
<p>src 是一个 DBIConnection 对象,from 参数要么是一个表明,要么是通过 <code>in_schema</code>指定的表名或者<code>sql</code>包裹的 sql 字符串.</p>
<pre class="r"><code>con &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;)
copy_to(con, mtcars)
DBI::dbListTables(con)</code></pre>
<p>通过<code>in_schema</code>查看数据</p>
<pre class="r"><code>con %&gt;% tbl(in_schema(&quot;temp&quot;, &quot;mtcars&quot;)) %&gt;% head(1)</code></pre>
<p>通过<code>sql</code>查看数据</p>
<pre class="r"><code>con %&gt;% tbl(sql(&quot;SELECT * FROM mtcars WHERE cyl = 8&quot;))</code></pre>
</div>
<div id="copy_to" class="section level3">
<h3>copy_to</h3>
<p><code>copy_to()</code>是 dplyr 中的函数,该函数功能即将本地数据框上传到远程数据源(数据库).</p>
<pre class="r"><code>copy_to(dest, df, name = deparse(substitute(df)), overwrite = FALSE, ...)</code></pre>
</div>
<div id="compute" class="section level3">
<h3>compute</h3>
<ul>
<li><p>compute 将计算后的结果作为临时表直接存在远程数据源中.</p></li>
<li><p>collect 将数据从远程数据源返回本地 R 中.</p></li>
<li><p>collapse 该函数不强制计算,但会强制生成 SQL,方便我们调试.</p></li>
</ul>
<pre class="r"><code>if (require(dbplyr)) {
  mtcars2 &lt;- src_memdb() %&gt;%
    copy_to(mtcars, name = &quot;mtcars2-cc&quot;, overwrite = TRUE)

  remote &lt;- mtcars2 %&gt;%
    filter(cyl == 8) %&gt;%
    select(mpg:drat)

  # 计算查询 将结果保存在远程数据源中
  compute(remote)

  # 计算查询 将结果返回本次session
  collect(remote)

  # 基于生成的 SQL 创建一个查询
  collapse(remote)
}</code></pre>
</div>
<div id="memdb_frame-系列" class="section level3">
<h3>memdb_frame 系列</h3>
<p><code>memdb_frame()</code>功能像<code>tibble::tibble()</code>,目的是在临时内存数据库中创建表.</p>
<pre class="r"><code># 创建临时内存数据库中的表
memdb_frame(..., .name = unique_table_name())

# 将df copy_to 到临时内存数据库中
tbl_memdb(df, name = deparse(substitute(df)))

# 临时内存数据库
src_memdb()</code></pre>
<pre class="r"><code>library(dplyr)
df &lt;- memdb_frame(x = runif(100), y = runif(100))
df %&gt;% arrange(x)
df %&gt;% arrange(x) %&gt;% show_query()

mtcars_db &lt;- tbl_memdb(mtcars)
mtcars_db %&gt;% group_by(cyl) %&gt;% summarise(n = n()) %&gt;% show_query()</code></pre>
</div>
<div id="simulate_dbi-系列" class="section level3">
<h3>simulate_dbi 系列</h3>
<p>该系列函数设计用来测试 SQL 语句的生成,而不是真正的连接一个真实的数据库.如下所示:</p>
<p>sqlite</p>
<pre class="r"><code>library(dplyr)
df &lt;- data.frame(x = 1, y = 2)

df_sqlite &lt;- tbl_lazy(df, con = simulate_sqlite())
df_sqlite %&gt;% summarise(x = sd(x, na.rm = TRUE)) %&gt;% show_query()</code></pre>
<p>mssql</p>
<pre class="r"><code>df &lt;- data.frame(x = 1, y = 2)
df_mssql &lt;- tbl_lazy(df, con = simulate_mssql(version = &quot;15.0&quot;))
df_mssql %&gt;% summarise(x = sd(x, na.rm = TRUE)) %&gt;% show_query()</code></pre>
<p>simulate_oracle</p>
<pre class="r"><code>df &lt;- data.frame(x = 1, y = 2)
df_mssql &lt;- tbl_lazy(df, con = simulate_oracle())
df_mssql %&gt;% summarise(z = paste0(x,y)) %&gt;% show_query()</code></pre>
<p>以上仅仅列出一小部分,更多函数以及用法请查看 <a href="https://cran.r-project.org/web/packages/dbplyr/dbplyr.pdf">dbplyr的函数手册</a></p>
</div>
<div id="dbplyr-支持的动词" class="section level3">
<h3>dbplyr 支持的动词</h3>
<p>大部分的 dplyr 的动词都支持,如 filter,count,tally,distinct,arrange,inner_join,left_join,intersect,union,setdiff,mutate,pull,select,rename,slice_min,slice_max,summarise等.</p>
<p>支持 tidyr 中的动词:pivot_longer,pivot_wider,replace_na,uncount,expand,fill 等</p>
</div>
</div>
<div id="案例" class="section level2">
<h2>案例</h2>
<p>案例以连接 MS SQL Server 和 Oracle 两种数据库为主,我们通过使用 odbc 后端连接 SQL Server 后 使用 dplyr 查询数据库,使用 ROracle 后端连接 oracle 数据库.</p>
<ul>
<li>连接 mssql</li>
</ul>
<pre class="r"><code>library(DBI)
# mssql
con_mssql_spb &lt;- dbConnect(odbc::odbc(),
  .connection_string =
    &quot;driver={ODBC Driver 17 for SQL Server};
                    server=172.16.88.2;
                    database=spb;
                    uid=zhongyf;
                    pwd=Zyf123456&quot;, timeout = 10,encoding = &#39;gbk&#39;
)</code></pre>
<ul>
<li>连接 oracle</li>
</ul>
<pre class="r"><code>library(ROracle)
drv &lt;- dbDriver(&quot;Oracle&quot;)
connect.string &lt;- &quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)
                    (HOST = 172.16.88.131)(PORT = 1521))
                     (CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = ghbi) ))&quot;
con &lt;- dbConnect(drv, username = &quot;pub_query&quot;, password = &quot;pub_query&quot;, dbname = connect.string)</code></pre>
<p>需要注意ROracle 包的安装,可以参考微信公众号文章<a href="https://mp.weixin.qq.com/s/QLwedZ5mTybqSXdHMTGRIw">R包ROracle安装</a>安装 ROracle.</p>
<div id="ms-sql-server" class="section level3">
<h3>MS SQL Server</h3>
<p>1.2021-01-01至2021-05-01 期间每月销售情况?</p>
<pre class="r"><code>tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(between(单据日期, &quot;2021-01-01&quot;, &quot;2021-05-31&quot;)) %&gt;%
  group_by(月 = month(单据日期)) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量)
  ) %&gt;%
  collect()</code></pre>
<p>在上诉案例中需要注意 <code>group_by()</code> 中的<code>month()</code>函数,在 base R 中没有<code>month</code>函数,这涉及到 dbplyr中的一个特性:对于不认识的函数将会保留,那我们就可以使用相应数据库的原生函数.</p>
<p>sql 实现</p>
<pre class="sql"><code>SELECT month(单据日期) 月,
  sum(金额) 销售额,
  sum(数量) 销售量
  FROM [spb].[dbo].[sales_order]
  where 单据日期 between &#39;2021-01-01&#39; and &#39;2021-05-31&#39;
  group by  month(单据日期)</code></pre>
<p>我们看看 dplyr 生成的 SQL 语句</p>
<pre class="r"><code>tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(between(单据日期, &quot;2021-01-01&quot;, &quot;2021-05-31&quot;)) %&gt;%
  group_by(月 = month(单据日期)) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量)
  ) %&gt;%
  show_query()</code></pre>
<p>dplyr 生成的 SQL 语句和我们自己编写的语句存在差异,自动生成的 SQL 语句多了一层嵌套,另外<code>month(单据日期)</code> 被翻译为 SQL 中的<code>DATEPART(MONTH, "单据日期") AS "月"</code></p>
<blockquote>
<p>不同数据库对时间日期的处理函数不一致.</p>
</blockquote>
<p>2.2021-01-01至2021-05-01 期间每个大区销售情况?</p>
<pre class="r"><code># 门店信息表
store_db &lt;- tbl(con_mssql_spb, &quot;store_table&quot;)
temp &lt;- tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(between(单据日期, &quot;2021-01-01&quot;, &quot;2021-05-31&quot;)) %&gt;%
  left_join(store_db, by = &quot;SHOP_NO&quot;) %&gt;%
  group_by(管辖区域) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量)
  ) %&gt;%
  arrange(desc(销售额))</code></pre>
<pre class="r"><code>temp %&gt;%
  show_query()

temp %&gt;%
  collect()</code></pre>
<p>SQL 实现</p>
<pre class="sql"><code>SELECT st.管辖区域,
  sum(sa.金额) 销售额,
  sum(sa.数量) 销售量
FROM [spb].[dbo].[sales_order] sa
left join   [spb].[dbo].[store_table] st on sa.SHOP_NO = st.SHOP_NO
where sa.单据日期 between &#39;2021-01-01&#39; and &#39;2021-05-31&#39;
group by   st.管辖区域
order by  sum(sa.金额) desc</code></pre>
<p>通过对比 dplyr 翻译的 SQL 和原生的 SQL,发现 dplyr 翻译的 SQL 比原生 SQL 会复杂很多,没有优化,运行花费时间会比原生 SQL 长.</p>
<p>2.近30天镜架销售超过100支的SKU,他们的销额,销量,折扣率,动销门店数,动销天数?</p>
<pre class="r"><code># 门店信息表
store_db &lt;- tbl(con_mssql_spb, &quot;store_table&quot;)
# 商品信息表
sku_db &lt;- tbl(con_mssql_spb, &quot;sku_table&quot;)

temp &lt;- tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(单据日期 &gt;= GETDATE() - 31L) %&gt;%
  # GETDATE 是数据库原生函数 思考为什么是减31
  left_join(store_db, by = &quot;SHOP_NO&quot;) %&gt;%
  left_join(sku_db, by = &quot;SKU_NO&quot;) %&gt;%
  filter(分析大类 == &quot;镜架&quot;) %&gt;%
  group_by(SKU_NO) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量),
    吊牌额 = sum(吊牌金额),
    动销门店数 = n_distinct(if_else(数量 &gt; 0, SHOP_NO, NA_character_)),
    动销天数 = n_distinct(if_else(数量 &gt; 0, 单据日期, NA_character_))
  ) %&gt;%
  mutate(折扣率 = 销售额 / 吊牌额) %&gt;%
  filter(销售量 &gt; 100) %&gt;%
  arrange(desc(销售量))</code></pre>
<p>返回数据集</p>
<pre class="r"><code>temp_dt &lt;- temp %&gt;%
  collect()

temp_dt %&gt;%
  slice_head(n = 10)

temp_dt %&gt;%
  slice_tail(n = 10)

# 动效门店数最多
temp_dt %&gt;%
  slice_max(动销门店数, n = 5)

# 折扣最低
temp_dt %&gt;%
  slice_min(折扣率, n = 5)</code></pre>
</div>
<div id="oracle" class="section level3">
<h3>Oracle</h3>
<p>连接 Oracle 数据库</p>
<pre class="r"><code>library(ROracle)
drv &lt;- dbDriver(&quot;Oracle&quot;)
connect.string &lt;- &quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)
                    (HOST = 172.16.88.131)(PORT = 1521))
                     (CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = ghbi) ))&quot;
con_oracle &lt;- dbConnect(drv, username = &quot;pub_query&quot;, password = &quot;pub_query&quot;, dbname = connect.string)</code></pre>
<p>注意 Oracle 中的 Schema 概念，我也不是太明白，但是通过 dbplyr 连接时需要主要，如下所示:</p>
<pre class="r"><code>tbl(con_oracle, in_schema(schema = &quot;DW&quot;, table = &quot;DW_SALE_SHOP_F&quot;))</code></pre>
<p>如果遇到乱码,通过设置语言环境变量即可,详见我的数据处理笔记数据库章节.</p>
<p>在 Oracle 中处理日期问题:2021-01-01至2021-05-01 期间每月销售情况?</p>
<pre class="r"><code>tbl(con_oracle, in_schema(schema = &quot;DW&quot;, table = &quot;DW_SALE_SHOP_F&quot;)) %&gt;%
  filter(between(
    BILL_DATE1, to_date(&quot;2021-01-01&quot;, &quot;yyyy-mm-dd&quot;),
    to_date(&quot;2021-05-31&quot;, &quot;yyyy-mm-dd&quot;)
  )) %&gt;%
  group_by(月 = month(BILL_DATE1)) %&gt;%
  summarise(
    销售额 = sum(BILL_MONEY2),
    销售量 = sum(POS_QTY)
  ) %&gt;%
  collect()</code></pre>
<p>SQL 实现</p>
<pre class="sql"><code>select EXTRACT(month from BILL_DATE1)月 ,
  sum(BILL_MONEY2) 销售额 ,
  sum(BILL_QTY) 销售量 
from DW.DW_SALE_SHOP_F t
where BILL_DATE1 between date&#39;2021-01-01&#39; and date&#39;2021-05-23&#39; 
group by  EXTRACT(month from BILL_DATE1)</code></pre>
<p>目前我使用的 Oracle 是 12C的版本,该版本目前不支持 month 函数,但是通过 dplyr 生成的 SQL 可以正确运行.不得不说,dplyr 在后台转化为 SQL 时做了很多工作.</p>
</div>
<div id="其他数据库" class="section level3">
<h3>其他数据库</h3>
<p>其他数据库由于使用不多,但是基本常用的数据库都支持良好,大家可以放心使用.</p>
</div>
</div>
<div id="dbplyr-总结" class="section level2">
<h2>dbplyr 总结</h2>
<p>通过上述讲解,我们大概清楚 dbplyr 的作用?将 dplyr 动词转化为 SQL,将生成的 SQL 的发送到远程数据库执行,最后将结果返回.</p>
<p>dbplyr 中最基础的几个函数:</p>
<ul>
<li>tbl / in_schema</li>
<li>show_query /explain</li>
<li>collect</li>
<li>sql</li>
</ul>
<p>由于 dbplyr 的内容比较多,我接触使用也没有太深入,大家可以自行浏览<a href="https://dbplyr.tidyverse.org/articles/dbplyr.html">dbplyr项目地址</a>学习.我们只需掌握最基本的几个函数,能用 dplyr 动词从数据库中获取想要的数据即可.</p>
</div>
<div id="参考资料" class="section level2">
<h2>参考资料</h2>
<p>1.https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html</p>
<p>2.https://cran.r-project.org/web/packages/dbplyr/vignettes/sql.html</p>
<p>3.https://cran.r-project.org/web/packages/dbplyr/vignettes/translation-verb.html</p>
<p>4.https://cran.r-project.org/web/packages/dbplyr/vignettes/new-backend.html</p>
</div>
