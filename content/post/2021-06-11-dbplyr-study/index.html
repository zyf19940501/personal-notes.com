---
title: 数据库与 R 包 dbplyr 交互
author: 宇飞的世界
date: '2021-06-11'
slug: dbplyr-study
categories:
  - R package
tags:
  - dbplyr
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<html>
<style> 
p{
  font-size:18px;
  line-height:2.0em;
}

.hljs-comment{
  font-family: Microsoft YaHei ;
  font-style: normal;
}
</style>
</html>
<div id="前言" class="section level2">
<h2>前言</h2>
<p>dbplyr 将 dplyr 包的函数转化为 SQL 语句去服务器(数据库)获取数据,在数据量较大、计算较多时,将远程连接数据库中
的表当作内存中的数据使用.当你使用的本机内存不够大时,可以充分利用服务器的性能(内存),这样做的好处不言而喻.</p>
<p>至于为什么使用 dbplyr 而不是直接编写 SQL,本人觉得优势如下所示：</p>
<ul>
<li><p>dbplyr 写起来简洁高效,基本跟用 dplyr 没有差别</p></li>
<li><p>能利用数据库所在服务器的算力,配合上并行计算,在处理大量数据时,大大加快速度.</p></li>
<li><p>不同数据库的语法存在差异,当源数据存在不同数据库时,用 R 包 dbplyr 和 dplyr 的统一语法,清洗数据加快效率</p></li>
<li><p>通过 dplyr 动词方便实现复杂的逻辑,当逻辑越复杂时 dbplyr 的优势越明显,不用一层层嵌套语句.</p></li>
</ul>
<p>当然也有一些劣势,比如在SQL Server 中 SQL 可以跨库查询,但是 dbplyr 无法直接跨库查询.</p>
<blockquote>
<p>dbplyr 在 oracle 可以跨不同 schema 查询</p>
</blockquote>
<p><a href="https://dbplyr.tidyverse.org/articles/dbplyr.html">dbplyr项目地址</a></p>
</div>
<div id="dbplyr-介绍" class="section level2">
<h2>dbplyr 介绍</h2>
<p>我们想要在数据库中使用<a href="https://bookdown.org/zhongyufei/Data-Handling-in-R/Data-Manipulation-dplyr.html">dplyr</a> ,需要先安装 dbplyr：</p>
<pre class="r"><code>install.packages(&quot;dbplyr&quot;)</code></pre>
<p>还需要有 R 包 DBI, DBI提供通用的接口,允许 dplyr 使用相同的代码函数处理不同的数据框,DBI 是 dbplyr 的依赖包,会跟随 dbplyr 安装.在我们使用dbplyr之前,需要确保已有数据库后端,比如常用的 <code>RMariaDB</code>,<code>RPostgres</code>,<code>RSQLite</code>,<code>odbc</code>,<code>ROracle</code>.如我常用 dbplyr 操作 MS SQL Server,就是使用 <code>odbc</code> 后端.</p>
<p>在本文介绍中,我们将主要使用<code>RSQLite</code>后端,因为这个数据库完全嵌入在R包,不依赖本地数据库环境,也不需要设置数据库服务器.所以说SQLite非常适合演示 『dbplyr 与 数据库交互』.本文将通过演示与 SQLite 交互,学习使用 dbplyr 包;最后在实际案例中演示,dbplyr 通过后端<code>odbc</code> 与 MS SQL Server 交互.</p>
<p>另外关于 R 语言 与数据库的交互,请参考我的<a href="https://bookdown.org/zhongyufei/Data-Handling-in-R/database.html">数据处理笔记</a>数据库章节.</p>
</div>
<div id="连接数据库" class="section level2">
<h2>连接数据库</h2>
<p>在 dbplyr 中使用数据库,首先需要通过<code>DBI::dbConnect()</code>连接数据库,关于怎么连接数据库详见数据处理笔记.</p>
<p>使用RSQLite 创建内存数据库:</p>
<pre class="r"><code>library(dplyr)</code></pre>
<pre><code>## 
## 载入程辑包：&#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre class="r"><code>library(DBI)
library(RSQLite)
library(dbplyr)</code></pre>
<pre><code>## 
## 载入程辑包：&#39;dbplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:dplyr&#39;:
## 
##     ident, sql</code></pre>
<pre class="r"><code>con &lt;- dbConnect(SQLite(), dbname = &quot;:memory:&quot;)</code></pre>
<p>一般情况下,数据库存在另外一台服务器上,我们需要这样连接,以 MS SQL 举例:</p>
<pre class="r"><code>con_study &lt;- dbConnect(odbc::odbc(),
  .connection_string =
    &quot;driver={ODBC Driver 17 for SQL Server};
                    server=192.168.2.236;
                    database=study;
                    uid=zhongyf;
                    pwd=Zyf123456&quot;, timeout = 10
)</code></pre>
<p>我们的临时内存数据库中暂时没有数据,需要我们将数据暂时保存到数据库中.通过<code>dplyr::copy_to()</code>即可:</p>
<pre class="r"><code>copy_to(con, nycflights13::flights, name = &quot;flights&quot;)</code></pre>
<p>现在在我们的临时数据库中已经有数据集了,我们可以通过<code>dbplyr::tbl()</code>来查看引用表:</p>
<pre class="r"><code>flights_db &lt;- tbl(con, &quot;flights&quot;)</code></pre>
<p>当我们查看获取的数据时,我们发现和本地的数据源导入R后基本一样:</p>
<pre class="r"><code>flights_db</code></pre>
<pre><code>## # Source:   table&lt;flights&gt; [?? x 19]
## # Database: sqlite 3.35.5 [:memory:]
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ... with more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dbl&gt;</code></pre>
<p>主要区别:我们看到数据源是来源数据库的远程数据源.</p>
</div>
<div id="查询数据库" class="section level2">
<h2>查询数据库</h2>
<p>我们在数据库中交互式,通常使用 SQL 查询,dbplyr 的目的是自动生成 SQL,但是 SQL 是一种非常大的语言,dbplyr 并不能完全代替,但是作为数据分析常用的 SQL,dbplyr 大部分都能帮助我们自动生成,我们可以继续使用我们熟悉的 dplyr 动词.</p>
<ul>
<li>select</li>
</ul>
<pre class="r"><code>flights_db %&gt;% select(year:day, dep_delay, arr_delay)</code></pre>
<pre><code>## # Source:   lazy query [?? x 5]
## # Database: sqlite 3.35.5 [:memory:]
##     year month   day dep_delay arr_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;
##  1  2013     1     1         2        11
##  2  2013     1     1         4        20
##  3  2013     1     1         2        33
##  4  2013     1     1        -1       -18
##  5  2013     1     1        -6       -25
##  6  2013     1     1        -4        12
##  7  2013     1     1        -5        19
##  8  2013     1     1        -3       -14
##  9  2013     1     1        -3        -8
## 10  2013     1     1        -2         8
## # ... with more rows</code></pre>
<pre class="r"><code>flights_db %&gt;% filter(dep_delay &gt; 240)</code></pre>
<pre><code>## # Source:   lazy query [?? x 19]
## # Database: sqlite 3.35.5 [:memory:]
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      848           1835       853     1001           1950
##  2  2013     1     1     1815           1325       290     2120           1542
##  3  2013     1     1     1842           1422       260     1958           1535
##  4  2013     1     1     2115           1700       255     2330           1920
##  5  2013     1     1     2205           1720       285       46           2040
##  6  2013     1     1     2343           1724       379      314           1938
##  7  2013     1     2     1332            904       268     1616           1128
##  8  2013     1     2     1412            838       334     1710           1147
##  9  2013     1     2     1607           1030       337     2003           1355
## 10  2013     1     2     2131           1512       379     2340           1741
## # ... with more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dbl&gt;</code></pre>
<pre class="r"><code>flights_db %&gt;%
  group_by(dest) %&gt;%
  summarise(delay = mean(dep_time))</code></pre>
<pre><code>## Warning: Missing values are always removed in SQL.
## Use `mean(x, na.rm = TRUE)` to silence this warning
## This warning is displayed only once per session.</code></pre>
<pre><code>## # Source:   lazy query [?? x 2]
## # Database: sqlite 3.35.5 [:memory:]
##    dest  delay
##    &lt;chr&gt; &lt;dbl&gt;
##  1 ABQ   2006.
##  2 ACK   1033.
##  3 ALB   1627.
##  4 ANC   1635.
##  5 ATL   1293.
##  6 AUS   1521.
##  7 AVL   1175.
##  8 BDL   1490.
##  9 BGR   1690.
## 10 BHM   1944.
## # ... with more rows</code></pre>
<p>普通的数据框和远程数据库查询之间的最重要区别在于,我们写的 R 代码被翻译成 SQL 并在远程服务器上的数据库中执行,而不是在本地的电脑上的 R 中执行.</p>
<p>在处理数据库时,dbplyr的懒惰特性将:</p>
<ul>
<li>除非我们明确要求,否则数据将永远不在 R 中,也就是永远存在在远程服务器中.</li>
<li>我们可以写很多 R 代码,最后将全部想做的事情,到最后再发给远程服务器的数据库中执行.</li>
</ul>
<p>如下所示:</p>
<pre class="r"><code>temp &lt;- flights_db %&gt;%
  group_by(tailnum) %&gt;%
  summarise(delay = mean(arr_delay), n = n()) %&gt;%
  arrange(desc(delay)) %&gt;%
  filter(n &gt; 100)</code></pre>
<p>通过运行上述代码,我们发现基本没有运行时间,也就是说上述代码并没有真正和数据库交互运行.直到我们请求数据(打印),dplyr 才会生成 SQL ,并从数据库请求结果.即使是打印数据,也没有将全部的数据参与运行,尽可能少的拉取几行返回.</p>
<p>通过<code>show_query()</code>我们可以看到 dplyr 生成的 SQL:</p>
<pre class="r"><code>temp %&gt;% show_query()</code></pre>
<pre><code>## Warning: ORDER BY is ignored in subqueries without LIMIT
## i Do you need to move arrange() later in the pipeline or use window_order() instead?</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT *
## FROM (SELECT `tailnum`, AVG(`arr_delay`) AS `delay`, COUNT(*) AS `n`
## FROM `flights`
## GROUP BY `tailnum`)
## WHERE (`n` &gt; 100.0)</code></pre>
<p>当我们编写调试完 R 代码后,我们通过<code>collect()</code>将数据从远程数据库中拉取到本地R中.</p>
<pre class="r"><code>temp_tbl &lt;- temp %&gt;% collect()</code></pre>
<pre><code>## Warning: ORDER BY is ignored in subqueries without LIMIT
## i Do you need to move arrange() later in the pipeline or use window_order() instead?</code></pre>
<pre class="r"><code>temp_tbl</code></pre>
<pre><code>## # A tibble: 1,201 x 3
##    tailnum delay     n
##    &lt;chr&gt;   &lt;dbl&gt; &lt;int&gt;
##  1 &lt;NA&gt;    NA     2512
##  2 N0EGMQ   9.98   371
##  3 N10156  12.7    153
##  4 N10575  20.7    289
##  5 N11106  14.9    129
##  6 N11107  15.0    148
##  7 N11109  14.9    148
##  8 N11113  15.8    138
##  9 N11119  30.3    148
## 10 N11121  10.3    154
## # ... with 1,191 more rows</code></pre>
</div>
<div id="函数解释" class="section level2">
<h2>函数解释</h2>
<div id="内存数据库" class="section level3">
<h3>内存数据库</h3>
<p>由于SQLite 是完全内嵌在 R 中,所以特别合适作为演示数据库,那怎么创建一个临时的数据库呢?如下所示:</p>
<pre class="r"><code>library(RSQLite)
con &lt;- dbConnect(SQLite(), dbname = &quot;:memory:&quot;)</code></pre>
<p>创建本地数据库 my-db.sqlite,通过这种方法创建的数据库会在当前目录下生成 my-db.sqlite 的文件,该文件即数据库文件.</p>
<pre class="r"><code># 创建 my-db 并连接
mydb &lt;- dbConnect(RSQLite::SQLite(), &quot;my-db.sqlite&quot;)
# 断开连接
dbDisconnect(mydb)
# 删除数据库文件
unlink(&quot;my-db.sqlite&quot;)</code></pre>
<p>或者是通过<code>dbname = ""</code>建立,该方式会临时在磁盘建立数据库,在关闭连接时会自动删除.</p>
<pre class="r"><code>con &lt;- dbConnect(SQLite(), dbname = &quot;&quot;)</code></pre>
</div>
<div id="tbl" class="section level3">
<h3>tbl</h3>
<p><code>tbl()</code>是 dplyr 里面的动词函数,是一个基于<code>src</code>调度的通用方法,从数据库中返回一个<code>tbl_dbi</code>对象.</p>
<pre class="r"><code>tbl(src, from, ...)</code></pre>
<p>src 是一个 DBIConnection 对象,from 参数要么是一个表明,要么是通过 <code>in_schema</code>指定的表名或者<code>sql</code>包裹的 sql 字符串.</p>
<pre class="r"><code>con &lt;- DBI::dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;)
copy_to(con, mtcars)
DBI::dbListTables(con)</code></pre>
<pre><code>## [1] &quot;mtcars&quot;       &quot;sqlite_stat1&quot; &quot;sqlite_stat4&quot;</code></pre>
<p>通过<code>in_schema</code>查看数据</p>
<pre class="r"><code>con %&gt;% tbl(in_schema(&quot;temp&quot;, &quot;mtcars&quot;)) %&gt;% head(1)</code></pre>
<pre><code>## # Source:   lazy query [?? x 11]
## # Database: sqlite 3.35.5 [:memory:]
##     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1    21     6   160   110   3.9  2.62  16.5     0     1     4     4</code></pre>
<p>通过<code>sql</code>查看数据</p>
<pre class="r"><code>con %&gt;% tbl(sql(&quot;SELECT * FROM mtcars WHERE cyl = 8&quot;))</code></pre>
<pre><code>## # Source:   SQL [?? x 11]
## # Database: sqlite 3.35.5 [:memory:]
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  2  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  3  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
##  4  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
##  5  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
##  6  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
##  7  10.4     8  460    215  3     5.42  17.8     0     0     3     4
##  8  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
##  9  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
## 10  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
## # ... with more rows</code></pre>
</div>
<div id="copy_to" class="section level3">
<h3>copy_to</h3>
<p><code>copy_to()</code>是 dplyr 中的函数,该函数功能即将本地数据框上传到远程数据源(数据库).</p>
<pre class="r"><code>copy_to(dest, df, name = deparse(substitute(df)), overwrite = FALSE, ...)</code></pre>
</div>
<div id="compute" class="section level3">
<h3>compute</h3>
<ul>
<li><p>compute 将计算后的结果作为临时表直接存在远程数据源中.</p></li>
<li><p>collect 将数据从远程数据源返回本地 R 中.</p></li>
<li><p>collapse 该函数不强制计算,但会强制生成 SQL,方便我们调试.</p></li>
</ul>
<pre class="r"><code>if (require(dbplyr)) {
  mtcars2 &lt;- src_memdb() %&gt;%
    copy_to(mtcars, name = &quot;mtcars2-cc&quot;, overwrite = TRUE)

  remote &lt;- mtcars2 %&gt;%
    filter(cyl == 8) %&gt;%
    select(mpg:drat)

  # 计算查询 将结果保存在远程数据源中
  compute(remote)

  # 计算查询 将结果返回本次session
  collect(remote)

  # 基于生成的 SQL 创建一个查询
  collapse(remote)
}</code></pre>
<pre><code>## # Source:   lazy query [?? x 5]
## # Database: sqlite 3.35.5 [:memory:]
##      mpg   cyl  disp    hp  drat
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  18.7     8  360    175  3.15
##  2  14.3     8  360    245  3.21
##  3  16.4     8  276.   180  3.07
##  4  17.3     8  276.   180  3.07
##  5  15.2     8  276.   180  3.07
##  6  10.4     8  472    205  2.93
##  7  10.4     8  460    215  3   
##  8  14.7     8  440    230  3.23
##  9  15.5     8  318    150  2.76
## 10  15.2     8  304    150  3.15
## # ... with more rows</code></pre>
</div>
<div id="memdb_frame-系列" class="section level3">
<h3>memdb_frame 系列</h3>
<p><code>memdb_frame()</code>功能像<code>tibble::tibble()</code>,目的是在临时内存数据库中创建表.</p>
<pre class="r"><code># 创建临时内存数据库中的表
memdb_frame(..., .name = unique_table_name())

# 将df copy_to 到临时内存数据库中
tbl_memdb(df, name = deparse(substitute(df)))

# 临时内存数据库
src_memdb()</code></pre>
<pre class="r"><code>library(dplyr)
df &lt;- memdb_frame(x = runif(100), y = runif(100))
df %&gt;% arrange(x)</code></pre>
<pre><code>## # Source:     table&lt;dbplyr_002&gt; [?? x 2]
## # Database:   sqlite 3.35.5 [:memory:]
## # Ordered by: x
##          x      y
##      &lt;dbl&gt;  &lt;dbl&gt;
##  1 0.00780 0.446 
##  2 0.0124  0.495 
##  3 0.0361  0.507 
##  4 0.0368  0.0829
##  5 0.0482  0.979 
##  6 0.0596  0.0285
##  7 0.0944  0.820 
##  8 0.0950  0.615 
##  9 0.117   0.648 
## 10 0.122   0.0947
## # ... with more rows</code></pre>
<pre class="r"><code>df %&gt;% arrange(x) %&gt;% show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT *
## FROM `dbplyr_002`
## ORDER BY `x`</code></pre>
<pre class="r"><code>mtcars_db &lt;- tbl_memdb(mtcars)
mtcars_db %&gt;% group_by(cyl) %&gt;% summarise(n = n()) %&gt;% show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT `cyl`, COUNT(*) AS `n`
## FROM `mtcars`
## GROUP BY `cyl`</code></pre>
</div>
<div id="simulate_dbi-系列" class="section level3">
<h3>simulate_dbi 系列</h3>
<p>该系列函数设计用来测试 SQL 语句的生成,而不是真正的连接一个真实的数据库.如下所示:</p>
<p>sqlite</p>
<pre class="r"><code>library(dplyr)
df &lt;- data.frame(x = 1, y = 2)

df_sqlite &lt;- tbl_lazy(df, con = simulate_sqlite())
df_sqlite %&gt;% summarise(x = sd(x, na.rm = TRUE)) %&gt;% show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT STDEV(`x`) AS `x`
## FROM `df`</code></pre>
<p>mssql</p>
<pre class="r"><code>df &lt;- data.frame(x = 1, y = 2)
df_mssql &lt;- tbl_lazy(df, con = simulate_mssql(version = &quot;15.0&quot;))
df_mssql %&gt;% summarise(x = sd(x, na.rm = TRUE)) %&gt;% show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT STDEV(`x`) AS `x`
## FROM `df`</code></pre>
<p>simulate_oracle</p>
<pre class="r"><code>df &lt;- data.frame(x = 1, y = 2)
df_mssql &lt;- tbl_lazy(df, con = simulate_oracle())
df_mssql %&gt;% summarise(z = paste0(x,y)) %&gt;% show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT `x` || `y` AS `z`
## FROM (`df`)</code></pre>
<p>以上仅仅列出一小部分,更多函数以及用法请查看 <a href="https://cran.r-project.org/web/packages/dbplyr/dbplyr.pdf">dbplyr的函数手册</a></p>
</div>
<div id="dbplyr-支持的动词" class="section level3">
<h3>dbplyr 支持的动词</h3>
<p>大部分的 dplyr 的动词都支持,如 filter,count,tally,distinct,arrange,inner_join,left_join,intersect,union,setdiff,mutate,pull,select,rename,slice_min,slice_max,summarise等.</p>
<p>支持 tidyr 中的动词:pivot_longer,pivot_wider,replace_na,uncount,expand,fill 等</p>
</div>
</div>
<div id="案例" class="section level2">
<h2>案例</h2>
<p>案例以连接 MS SQL Server 和 Oracle 两种数据库为主,我们通过使用 odbc 后端连接 SQL Server 后 使用 dplyr 查询数据库,使用 ROracle 后端连接 oracle 数据库.</p>
<ul>
<li>连接 mssql</li>
</ul>
<pre class="r"><code>library(DBI)
# mssql
con_mssql_spb &lt;- dbConnect(odbc::odbc(),
  .connection_string =
    &quot;driver={ODBC Driver 17 for SQL Server};
                    server=172.16.88.2;
                    database=spb;
                    uid=zhongyf;
                    pwd=Zyf123456&quot;, timeout = 10,encoding = &#39;gbk&#39;
)</code></pre>
<ul>
<li>连接 oracle</li>
</ul>
<pre class="r"><code>library(ROracle)
drv &lt;- dbDriver(&quot;Oracle&quot;)
connect.string &lt;- &quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)
                    (HOST = 172.16.88.131)(PORT = 1521))
                     (CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = ghbi) ))&quot;
con &lt;- dbConnect(drv, username = &quot;pub_query&quot;, password = &quot;pub_query&quot;, dbname = connect.string)</code></pre>
<p>需要注意ROracle 包的安装,可以参考微信公众号文章<a href="https://mp.weixin.qq.com/s/QLwedZ5mTybqSXdHMTGRIw">R包ROracle安装</a>安装 ROracle.</p>
<div id="ms-sql-server" class="section level3">
<h3>MS SQL Server</h3>
<p>1.2021-01-01至2021-05-01 期间每月销售情况?</p>
<pre class="r"><code>tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(between(单据日期, &quot;2021-01-01&quot;, &quot;2021-05-31&quot;)) %&gt;%
  group_by(月 = month(单据日期)) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量)
  ) %&gt;%
  collect()</code></pre>
<pre><code>## Warning: Missing values are always removed in SQL.
## Use `SUM(x, na.rm = TRUE)` to silence this warning
## This warning is displayed only once per session.</code></pre>
<pre><code>## # A tibble: 5 x 3
##      月    销售额 销售量
##   &lt;int&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1     1 51430112. 198950
## 2     2 68389455. 268733
## 3     3 62714046. 246805
## 4     4 65332434. 259966
## 5     5 76908951. 317079</code></pre>
<p>在上诉案例中需要注意 <code>group_by()</code> 中的<code>month()</code>函数,在 base R 中没有<code>month</code>函数,这涉及到 dbplyr中的一个特性:对于不认识的函数将会保留,那我们就可以使用相应数据库的原生函数.</p>
<p>sql 实现</p>
<pre class="sql"><code>SELECT month(单据日期) 月,
  sum(金额) 销售额,
  sum(数量) 销售量
  FROM [spb].[dbo].[sales_order]
  where 单据日期 between &#39;2021-01-01&#39; and &#39;2021-05-31&#39;
  group by  month(单据日期)</code></pre>
<div class="knitsql-table">
<table>
<caption><span id="tab:unnamed-chunk-28">Table 1: </span>5 records</caption>
<thead>
<tr class="header">
<th align="left">月</th>
<th align="right">销售额</th>
<th align="right">销售量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">51430112</td>
<td align="right">198950</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">68389455</td>
<td align="right">268733</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">62714046</td>
<td align="right">246805</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="right">65332434</td>
<td align="right">259966</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="right">76908951</td>
<td align="right">317079</td>
</tr>
</tbody>
</table>
</div>
<p>我们看看 dplyr 生成的 SQL 语句</p>
<pre class="r"><code>tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(between(单据日期, &quot;2021-01-01&quot;, &quot;2021-05-31&quot;)) %&gt;%
  group_by(月 = month(单据日期)) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量)
  ) %&gt;%
  show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT &quot;月&quot;, SUM(&quot;金额&quot;) AS &quot;销售额&quot;, SUM(&quot;数量&quot;) AS &quot;销售量&quot;
## FROM (SELECT &quot;订单号&quot;, &quot;单据日期&quot;, &quot;SHOP_NO&quot;, &quot;SKU_NO&quot;, &quot;会员编号&quot;, &quot;金额&quot;, &quot;数量&quot;, &quot;吊牌金额&quot;, DATEPART(MONTH, &quot;单据日期&quot;) AS &quot;月&quot;
## FROM &quot;sales_order&quot;
## WHERE (&quot;单据日期&quot; BETWEEN &#39;2021-01-01&#39; AND &#39;2021-05-31&#39;)) &quot;q01&quot;
## GROUP BY &quot;月&quot;</code></pre>
<p>dplyr 生成的 SQL 语句和我们自己编写的语句存在差异,自动生成的 SQL 语句多了一层嵌套,另外<code>month(单据日期)</code> 被翻译为 SQL 中的<code>DATEPART(MONTH, "单据日期") AS "月"</code></p>
<blockquote>
<p>不同数据库对时间日期的处理函数不一致.</p>
</blockquote>
<p>2.2021-01-01至2021-05-01 期间每个大区销售情况?</p>
<pre class="r"><code># 门店信息表
store_db &lt;- tbl(con_mssql_spb, &quot;store_table&quot;)
temp &lt;- tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(between(单据日期, &quot;2021-01-01&quot;, &quot;2021-05-31&quot;)) %&gt;%
  left_join(store_db, by = &quot;SHOP_NO&quot;) %&gt;%
  group_by(管辖区域) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量)
  ) %&gt;%
  arrange(desc(销售额))</code></pre>
<pre class="r"><code>temp %&gt;%
  show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT &quot;管辖区域&quot;, SUM(&quot;金额&quot;) AS &quot;销售额&quot;, SUM(&quot;数量&quot;) AS &quot;销售量&quot;
## FROM (SELECT &quot;订单号&quot;, &quot;单据日期&quot;, &quot;LHS&quot;.&quot;SHOP_NO&quot; AS &quot;SHOP_NO&quot;, &quot;SKU_NO&quot;, &quot;会员编号&quot;, &quot;金额&quot;, &quot;数量&quot;, &quot;吊牌金额&quot;, &quot;门店名称&quot;, &quot;原ERP店编码&quot;, &quot;品牌&quot;, &quot;一级部门&quot;, &quot;门店性质&quot;, &quot;国家&quot;, &quot;管辖区域&quot;, &quot;省份&quot;, &quot;城市&quot;, &quot;城市等级&quot;, &quot;门店负责人&quot;, &quot;区域经理&quot;, &quot;经营状态&quot;, &quot;店铺类型&quot;, &quot;老板&quot;, &quot;加盟商编码&quot;, &quot;加盟商名称&quot;, &quot;重点客户标识&quot;, &quot;年可比店&quot;, &quot;当月可比店&quot;, &quot;门店属性&quot;, &quot;区域&quot;, &quot;仓位类型&quot;, &quot;调整城市&quot;
## FROM (SELECT *
## FROM &quot;sales_order&quot;
## WHERE (&quot;单据日期&quot; BETWEEN &#39;2021-01-01&#39; AND &#39;2021-05-31&#39;)) &quot;LHS&quot;
## LEFT JOIN &quot;store_table&quot; AS &quot;RHS&quot;
## ON (&quot;LHS&quot;.&quot;SHOP_NO&quot; = &quot;RHS&quot;.&quot;SHOP_NO&quot;)
## ) &quot;q01&quot;
## GROUP BY &quot;管辖区域&quot;
## ORDER BY &quot;销售额&quot; DESC</code></pre>
<pre class="r"><code>temp %&gt;%
  collect()</code></pre>
<pre><code>## # A tibble: 5 x 3
##   管辖区域    销售额 销售量
##   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;
## 1 华东     95518933. 368410
## 2 华北     79995909. 275645
## 3 华西     75412725. 337205
## 4 华南     73768014. 309546
## 5 总部        79416.    727</code></pre>
<p>SQL 实现</p>
<pre class="sql"><code>SELECT st.管辖区域,
  sum(sa.金额) 销售额,
  sum(sa.数量) 销售量
FROM [spb].[dbo].[sales_order] sa
left join   [spb].[dbo].[store_table] st on sa.SHOP_NO = st.SHOP_NO
where sa.单据日期 between &#39;2021-01-01&#39; and &#39;2021-05-31&#39;
group by   st.管辖区域
order by  sum(sa.金额) desc</code></pre>
<div class="knitsql-table">
<table>
<caption><span id="tab:unnamed-chunk-32">Table 2: </span>5 records</caption>
<thead>
<tr class="header">
<th align="left">管辖区域</th>
<th align="right">销售额</th>
<th align="right">销售量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">华东</td>
<td align="right">95518932.72</td>
<td align="right">368410</td>
</tr>
<tr class="even">
<td align="left">华北</td>
<td align="right">79995909.29</td>
<td align="right">275645</td>
</tr>
<tr class="odd">
<td align="left">华西</td>
<td align="right">75412725.15</td>
<td align="right">337205</td>
</tr>
<tr class="even">
<td align="left">华南</td>
<td align="right">73768014.47</td>
<td align="right">309546</td>
</tr>
<tr class="odd">
<td align="left">总部</td>
<td align="right">79416.44</td>
<td align="right">727</td>
</tr>
</tbody>
</table>
</div>
<p>通过对比 dplyr 翻译的 SQL 和原生的 SQL,发现 dplyr 翻译的 SQL 比原生 SQL 会复杂很多,没有优化,运行花费时间会比原生 SQL 长.</p>
<p>2.近30天镜架销售超过100支的SKU,他们的销额,销量,折扣率,动销门店数,动销天数?</p>
<pre class="r"><code># 门店信息表
store_db &lt;- tbl(con_mssql_spb, &quot;store_table&quot;)
# 商品信息表
sku_db &lt;- tbl(con_mssql_spb, &quot;sku_table&quot;)

temp &lt;- tbl(con_mssql_spb, &quot;sales_order&quot;) %&gt;%
  filter(单据日期 &gt;= GETDATE() - 31L) %&gt;%
  # GETDATE 是数据库原生函数 思考为什么是减31
  left_join(store_db, by = &quot;SHOP_NO&quot;) %&gt;%
  left_join(sku_db, by = &quot;SKU_NO&quot;) %&gt;%
  filter(分析大类 == &quot;镜架&quot;) %&gt;%
  group_by(SKU_NO) %&gt;%
  summarise(
    销售额 = sum(金额),
    销售量 = sum(数量),
    吊牌额 = sum(吊牌金额),
    动销门店数 = n_distinct(if_else(数量 &gt; 0, SHOP_NO, NA_character_)),
    动销天数 = n_distinct(if_else(数量 &gt; 0, 单据日期, NA_character_))
  ) %&gt;%
  mutate(折扣率 = 销售额 / 吊牌额) %&gt;%
  filter(销售量 &gt; 100) %&gt;%
  arrange(desc(销售量))</code></pre>
<p>返回数据集</p>
<pre class="r"><code>temp_dt &lt;- temp %&gt;%
  collect()

temp_dt %&gt;%
  slice_head(n = 10)</code></pre>
<pre><code>## # A tibble: 10 x 7
##    SKU_NO          销售额 销售量 吊牌额 动销门店数 动销天数 折扣率
##    &lt;chr&gt;            &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;
##  1 MJ101FF072GYC3 335276.    503 351597        269       30  0.954
##  2 MJ101FG018GDC3 193485.    403 201097        256       30  0.962
##  3 MJ101FF074TYC2 203462.    302 211098        206       30  0.964
##  4 MJ101FF011GDC2 197898.    298 208302        212       30  0.950
##  5 MJ101FG020GYC2 198774.    298 208302        196       30  0.954
##  6 MJ102FG013GUC1 200074.    297 207603        208       30  0.964
##  7 MJ101FF068GRC2 142422.    297 148203        189       30  0.961
##  8 MJ101FG005BKC1 137765.    284 141716        191       30  0.972
##  9 MJ101FG021BKC1 188810.    283 197118        211       30  0.958
## 10 MJ101FG020TEC1 184887.    279 195021        208       30  0.948</code></pre>
<pre class="r"><code>temp_dt %&gt;%
  slice_tail(n = 10)</code></pre>
<pre><code>## # A tibble: 10 x 7
##    SKU_NO         销售额 销售量 吊牌额 动销门店数 动销天数 折扣率
##    &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;
##  1 MJ101FG033BKC2 77649.    116  81084        108       29  0.958
##  2 MJ102FG022GYC2 65005.    112  67088         91       30  0.969
##  3 MJ101FG006SLC2 61890.    110  65890         92       28  0.939
##  4 MJ102FF047BKC1 51882.    110  54890         92       29  0.945
##  5 MJ101FF011GDC4 72359.    109  76191         86       29  0.950
##  6 MJ101FF064SLC3 60611.    108  64692         91       28  0.937
##  7 FM1820172C01   68783.    107  74793         89       29  0.920
##  8 MJ101FF011SLC3 69095.    104  71997         84       26  0.960
##  9 FM1820154C03   66632.    104  72696         83       24  0.917
## 10 MJ101FG003BRC3 59080.    102  61098         92       30  0.967</code></pre>
<pre class="r"><code># 动效门店数最多
temp_dt %&gt;%
  slice_max(动销门店数, n = 5)</code></pre>
<pre><code>## # A tibble: 6 x 7
##   SKU_NO          销售额 销售量 吊牌额 动销门店数 动销天数 折扣率
##   &lt;chr&gt;            &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;
## 1 MJ101FF072GYC3 335276.    503 351597        269       30  0.954
## 2 MJ101FG018GDC3 193485.    403 201097        256       30  0.962
## 3 MJ101FF011GDC2 197898.    298 208302        212       30  0.950
## 4 MJ101FG021BKC1 188810.    283 197118        211       30  0.958
## 5 MJ102FG013GUC1 200074.    297 207603        208       30  0.964
## 6 MJ101FG020TEC1 184887.    279 195021        208       30  0.948</code></pre>
<pre class="r"><code># 折扣最低
temp_dt %&gt;%
  slice_min(折扣率, n = 5)</code></pre>
<pre><code>## # A tibble: 5 x 7
##   SKU_NO         销售额 销售量 吊牌额 动销门店数 动销天数 折扣率
##   &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;int&gt;    &lt;int&gt;  &lt;dbl&gt;
## 1 FM1820154C03   66632.    104  72696         83       24  0.917
## 2 FM1820172C02   94843.    148 103452        119       29  0.917
## 3 FM1820172C01   68783.    107  74793         89       29  0.920
## 4 FM1720084C02   79580.    171  85329        122       28  0.933
## 5 MJ101FF064SLC3 60611.    108  64692         91       28  0.937</code></pre>
</div>
<div id="oracle" class="section level3">
<h3>Oracle</h3>
<p>连接 Oracle 数据库</p>
<pre class="r"><code>library(ROracle)
drv &lt;- dbDriver(&quot;Oracle&quot;)
connect.string &lt;- &quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)
                    (HOST = 172.16.88.131)(PORT = 1521))
                     (CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = ghbi) ))&quot;
con_oracle &lt;- dbConnect(drv, username = &quot;pub_query&quot;, password = &quot;pub_query&quot;, dbname = connect.string)</code></pre>
<p>注意 Oracle 中的 Schema 概念，我也不是太明白，但是通过 dbplyr 连接时需要主要，如下所示:</p>
<pre class="r"><code>tbl(con_oracle, in_schema(schema = &quot;DW&quot;, table = &quot;DW_SALE_SHOP_F&quot;))</code></pre>
<pre><code>## # Source:   table&lt;&quot;DW&quot;.&quot;DW_SALE_SHOP_F&quot;&gt; [?? x 33]
## # Database: OraConnection
##    SHOP_NO BILL_DATE           BILL_DATE1          POS_NO    POS_NO1   SKU_NO   
##    &lt;chr&gt;   &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    
##  1 6287    2016-06-01 00:00:00 2016-06-01 00:00:00 SACA0001~ SACA0001~ EM160D00~
##  2 6281    2016-06-12 00:00:00 2016-06-01 00:00:00 SACA0024~ SACA0024~ EM156C00~
##  3 210573  2016-06-01 00:00:00 2016-06-01 00:00:00 SACA0067~ SACA0067~ SA161022~
##  4 210570  2016-06-01 00:00:00 2016-06-01 00:00:00 SACA0040~ SACA0040~ SA161021~
##  5 CW0071  2016-06-01 00:00:00 2016-06-01 00:00:00 SACW0071~ SACW0071~ WPSP00031
##  6 6286    2016-06-05 00:00:00 2016-06-01 00:00:00 SACA0006~ SACA0006~ EM167C00~
##  7 6154    2016-06-01 00:00:00 2016-06-01 00:00:00 SBCW0032~ SBCW0032~ WPSP00108
##  8 210588  2016-06-01 00:00:00 2016-06-01 00:00:00 SACA0143~ SACA0143~ JATRE001~
##  9 210871  2016-06-01 00:00:00 2016-06-01 00:00:00 SACA0147~ SACA0147~ EM160C00~
## 10 6694    2016-06-01 00:00:00 2016-06-01 00:00:00 SACA0091~ SACA0091~ SA161022~
## # ... with more rows, and 27 more variables: CUSTOM_NO &lt;chr&gt;, BILL_QTY &lt;dbl&gt;,
## #   BILL_MONEY &lt;dbl&gt;, BILL_MONEY1 &lt;dbl&gt;, PRICE &lt;dbl&gt;, COST &lt;dbl&gt;,
## #   STOCK_COST &lt;dbl&gt;, SALE_TYPE &lt;chr&gt;, CLUB_NO &lt;chr&gt;, PEOP_NO &lt;chr&gt;,
## #   CURRENCY &lt;chr&gt;, ERP_NO &lt;chr&gt;, CX_NO &lt;chr&gt;, TYPE01 &lt;dbl&gt;, TYPE02 &lt;dbl&gt;,
## #   ETL_DATE &lt;dttm&gt;, POS_QTY &lt;dbl&gt;, GOOS_TYPE &lt;dbl&gt;, DIST_PRICE &lt;dbl&gt;,
## #   BILL_QTY1 &lt;dbl&gt;, SHOP_TYP &lt;dbl&gt;, BILL_MONEY2 &lt;dbl&gt;, POS_ID &lt;dbl&gt;,
## #   QY_CODE &lt;chr&gt;, QD_CODE &lt;chr&gt;, JMS_CODE &lt;chr&gt;, DATA_TYP &lt;dbl&gt;</code></pre>
<p>如果遇到乱码,通过设置语言环境变量即可,详见我的数据处理笔记数据库章节.</p>
<p>在 Oracle 中处理日期问题:2021-01-01至2021-05-01 期间每月销售情况?</p>
<pre class="r"><code>tbl(con_oracle, in_schema(schema = &quot;DW&quot;, table = &quot;DW_SALE_SHOP_F&quot;)) %&gt;%
  filter(between(
    BILL_DATE1, to_date(&quot;2021-01-01&quot;, &quot;yyyy-mm-dd&quot;),
    to_date(&quot;2021-05-31&quot;, &quot;yyyy-mm-dd&quot;)
  )) %&gt;%
  group_by(月 = month(BILL_DATE1)) %&gt;%
  summarise(
    销售额 = sum(BILL_MONEY2),
    销售量 = sum(POS_QTY)
  ) %&gt;%
  collect()</code></pre>
<pre><code>## # A tibble: 5 x 3
##      月     销售额 销售量
##   &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;
## 1     1 114068765. 402595
## 2     2 137965390. 510844
## 3     4 140264700. 444766
## 4     5 153812950. 514007
## 5     3 131011264. 450359</code></pre>
<p>SQL 实现</p>
<pre class="sql"><code>select EXTRACT(month from BILL_DATE1)月 ,
  sum(BILL_MONEY2) 销售额 ,
  sum(BILL_QTY) 销售量 
from DW.DW_SALE_SHOP_F t
where BILL_DATE1 between date&#39;2021-01-01&#39; and date&#39;2021-05-23&#39; 
group by  EXTRACT(month from BILL_DATE1)</code></pre>
<div class="knitsql-table">
<table>
<caption><span id="tab:unnamed-chunk-38">Table 3: </span>5 records</caption>
<thead>
<tr class="header">
<th align="right">月</th>
<th align="right">销售额</th>
<th align="right">销售量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">114068765</td>
<td align="right">498791</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">137965390</td>
<td align="right">580572</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="right">140264700</td>
<td align="right">634358</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="right">123258395</td>
<td align="right">816289</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">131011264</td>
<td align="right">585744</td>
</tr>
</tbody>
</table>
</div>
<p>目前我使用的 Oracle 是 12C的版本,该版本目前不支持 month 函数,但是通过 dplyr 生成的 SQL 可以正确运行.不得不说,dplyr 在后台转化为 SQL 时做了很多工作.</p>
</div>
<div id="其他数据库" class="section level3">
<h3>其他数据库</h3>
<p>其他数据库由于使用不多,但是基本常用的数据库都支持良好,大家可以放心使用.</p>
</div>
</div>
<div id="dbplyr-总结" class="section level2">
<h2>dbplyr 总结</h2>
<p>通过上述讲解,我们大概清楚 dbplyr 的作用?将 dplyr 动词转化为 SQL,将生成的 SQL 的发送到远程数据库执行,最后将结果返回.</p>
<p>dbplyr 中最基础的几个函数:</p>
<ul>
<li>tbl / in_schema</li>
<li>show_query /explain</li>
<li>collect</li>
<li>sql</li>
</ul>
<p>由于 dbplyr 的内容比较多,我接触使用也没有太深入,大家可以自行浏览<a href="https://dbplyr.tidyverse.org/articles/dbplyr.html">dbplyr项目地址</a>学习.我们只需掌握最基本的几个函数,能用 dplyr 动词从数据库中获取想要的数据即可.</p>
</div>
<div id="参考资料" class="section level2">
<h2>参考资料</h2>
<p>1.https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html</p>
<p>2.https://cran.r-project.org/web/packages/dbplyr/vignettes/sql.html</p>
<p>3.https://cran.r-project.org/web/packages/dbplyr/vignettes/translation-verb.html</p>
<p>4.https://cran.r-project.org/web/packages/dbplyr/vignettes/new-backend.html</p>
</div>
