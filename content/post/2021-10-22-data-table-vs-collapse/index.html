---
title: 'R 包 data.table 与 collapse 比较'
author: 宇飞的世界
date: '2021-10-22'
output:
  html_document: default
slug: data-table-vs-collapse
categories:
  - R package
tags: [handle data]
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<div id="前言" class="section level2">
<h2>前言</h2>
<p>当我知道 collapse 包时，我第一时间去 GitHub 上查看该项目。由于我长期使用 data.table 包处理数据，所以特别想知道他们之间的优劣势，通过查看基准测试，发现两个项目各有所长。由于我是一名零售行业数据分析师，需要的数据处理函数以及逻辑相对比较简单，接下来就两个 R 包在数据处理上的差异做简单的记录，主要比较相同的处理逻辑语法上的差异。</p>
<p>官方的手册中已有相关<a href="https://sebkrantz.github.io/collapse/articles/collapse_and_data.table.html">介绍</a>，可自行前往阅读。</p>
</div>
<div id="基础用法" class="section level2">
<h2>基础用法</h2>
<pre class="r"><code># 加载包
library(collapse)
library(data.table)
# 准备测试数据
# collapse data
df &lt;- readxl::read_excel(&#39;/Users/zhongyf/Desktop/datatable vs collapse.xlsx&#39;)
# data.table data
dt &lt;- readxl::read_excel(&#39;/Users/zhongyf/Desktop/datatable vs collapse.xlsx&#39;) |&gt; setDT()</code></pre>
<div id="行列选择" class="section level3">
<h3>行列选择</h3>
<p>列选择，新出来的数据处理框架基本都支持列名索引和数字索引的方式选择列，建议使用列名索引。</p>
<p>collapse 行列选择与tidyverse系列相似,支持列名索引以及数字索引。</p>
<ul>
<li>列选择</li>
</ul>
<ol style="list-style-type: decimal">
<li>collapse</li>
</ol>
<pre class="r"><code>df |&gt; fselect(BILL_DATE,POS_NO,SKU_NO,SHOP_NO,BILL_QTY) |&gt; head()
df |&gt; fselect(1:3,12) |&gt; head()</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>data.table</li>
</ol>
<pre class="r"><code>dt[,.(BILL_DATE,POS_NO,SKU_NO,SHOP_NO,BILL_QTY)] |&gt; head()
dt[,c(1:3,12)] |&gt; head()</code></pre>
<ul>
<li>子集(行选择)</li>
</ul>
<ol style="list-style-type: decimal">
<li>collapse</li>
</ol>
<pre class="r"><code># 筛选子集 行列同时
fsubset(df,SHOP_NO ==&quot;999842&quot; &amp; BILL_MONEY&gt;10,BILL_DATE,POS_NO,SKU_NO,SHOP_NO,BILL_QTY) |&gt; 
  head()</code></pre>
<p>简写方式, <code>sbt()</code>是的<code>fsubset()</code>简写。</p>
<pre class="r"><code>sbt(df,SHOP_NO ==&quot;999842&quot; &amp; BILL_MONEY&gt;10,BILL_DATE,POS_NO,SKU_NO,SHOP_NO,BILL_QTY) |&gt; 
  head()</code></pre>
<p>ss 是一种比 <code>dt[1:10, 2:3]</code>更快取子集的方式：</p>
<pre class="r"><code>ss(df,1:2,1:5)</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>data.table</li>
</ol>
<pre class="r"><code>dt[SHOP_NO ==&quot;999842&quot; &amp; BILL_MONEY&gt;10,.(BILL_DATE,POS_NO,SKU_NO,SHOP_NO,BILL_QTY)] |&gt; 
  head()</code></pre>
<p>collapse 的列选择以及子集，集合了 tidyverse 中 dpblyr 和 data.table 的特性。</p>
</div>
<div id="重新排列行" class="section level3">
<h3>重新排列行</h3>
<ol style="list-style-type: decimal">
<li>collapse</li>
</ol>
<p>在 collapse 中<code>roworder</code>是一个类比<code>dplyr::arrange</code>的函数，按照作者说法是受到<code>data.table::setorder</code>启发的一个函数。</p>
<pre class="r"><code>roworder(df,SHOP_NO) |&gt; 
  ss(1:2,1:5)

roworder(df,-SHOP_NO) |&gt; 
  ss(1:2,1:5)</code></pre>
<blockquote>
<p>除非数据已经排序，否则roworder创建数据框的副本</p>
</blockquote>
<pre class="r"><code>roworderv(df,cols = c(&quot;SHOP_NO&quot;,&quot;SKU_NO&quot;),decreasing = c(TRUE,FALSE)) |&gt; 
  head()</code></pre>
<pre class="r"><code>roworderv(df,neworder = df$SHOP_NO==&#39;999842&#39;) |&gt; 
  head()

roworderv(df,neworder = df$SHOP_NO==&#39;999842&#39;,pos = &#39;end&#39;) |&gt; 
  tail()</code></pre>
<p>官方案例如下：</p>
<pre class="r"><code>roworderv(GGDC10S, 
          neworder = with(GGDC10S, 
                          c(which(Country == &quot;GHA&quot;),
                          which(Country == &quot;BWA&quot;))), pos = &quot;exchange&quot;) |&gt;                  ss(1:2, 1:8)</code></pre>
<p>2.data.table</p>
<pre class="r"><code>setorder(dt,SHOP_NO) # 不产生副本</code></pre>
<pre class="r"><code>setorderv(dt,cols = c(&quot;SHOP_NO&quot;,&quot;SKU_NO&quot;),order = c(1L,-1L))</code></pre>
</div>
<div id="重新排列列" class="section level3">
<h3>重新排列列</h3>
<ol style="list-style-type: decimal">
<li>collapse</li>
</ol>
<pre class="r"><code>colorder(df,BILL_DATE,BILL_DATE1,SHOP_NO,SKU_NO,BILL_QTY) |&gt; 
  ss(1:5,1:5)</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>data.table</li>
</ol>
<pre class="r"><code>setcolorder(dt,neworder = c(&quot;BILL_DATE&quot;,&quot;BILL_DATE1&quot;,&quot;SHOP_NO&quot;,&quot;SKU_NO&quot;,&quot;BILL_QTY&quot;))</code></pre>
<p>在列的重排上，collapse 和 data.table 上基本一致。</p>
</div>
<div id="转换和计算新列" class="section level3">
<h3>转换和计算新列</h3>
<p><code>ftransform</code> 函数从中<code>base::transform</code> 改进。</p>
<ol style="list-style-type: decimal">
<li>collapse</li>
</ol>
<p>新增列</p>
<pre class="r"><code>ftransform(df,吊牌价 = BILL_QTY * PRICE) |&gt; 
  fselect(SHOP_NO,BILL_QTY,PRICE,吊牌价) |&gt; 
  ss(1:6,1:4)</code></pre>
<p>计算现有列</p>
<pre class="r"><code>ftransform(df,BILL_QTY = BILL_QTY * 2) #修改了原始 df 的数据</code></pre>
<p>删除列</p>
<pre class="r"><code>ftransform(df,BILL_QTY = NULL) |&gt; ncol()
df |&gt; ncol()</code></pre>
<p>批量操作</p>
<pre class="r"><code>ftransformv(df,vars = c(&#39;BILL_QTY&#39;,&#39;BILL_MONEY&#39;),FUN = \ (x){x*2}) |&gt; 
  fselect(SHOP_NO,BILL_DATE,BILL_QTY,BILL_MONEY)</code></pre>
<p>分组聚合</p>
<pre class="r"><code>df |&gt; 
  fgroup_by(SHOP_NO) |&gt; 
  fsummarise(销量 = fsum(BILL_QTY))</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>data.table</li>
</ol>
<pre class="r"><code>dt[,BILL_QTY := BILL_QTY * 2] # 修改了原始 dt 数据</code></pre>
<p>批量操作</p>
<pre class="r"><code>dt[,colnames(dt[,.(BILL_QTY,BILL_MONEY)]):=lapply(.SD[,.(BILL_QTY,BILL_MONEY)],\ (x){x*2})][,.(SHOP_NO,BILL_DATE,BILL_QTY,BILL_MONEY)]</code></pre>
<p>data.table 中的批量操作方便给新列重新命名。</p>
<p>分组聚合</p>
<pre class="r"><code>dt[,.(销量 = sum(BILL_QTY)),by=.(SHOP_NO)]</code></pre>
</div>
<div id="列重命名" class="section level3">
<h3>列重命名</h3>
<pre class="r"><code>frename(df,BILL_QTY = qty, BILL_MONEY = money ) |&gt; 
  head(2)

frename(df, tolower, cols = .c(BILL_QTY, BILL_MONEY)) %&gt;% head(2)</code></pre>
<p>自定义函数改名</p>
<pre class="r"><code>frename(iris, paste, &quot;new&quot;, sep = &quot;_&quot;, cols = 1:2)</code></pre>
<p>改变数据框</p>
<pre class="r"><code>setrename(df,BILL_QTY = qty, BILL_MONEY = money ) </code></pre>
</div>
</div>
